import numpy as np
from numpy import sum, sqrt
import pandas as pd
import pandas_datareader.data as web
import scipy.optimize as sco
import csv
import time
import datetime as dt
#**Files paths need to be changed to where file is actually stored on individuals computer

#############################Global Variable####################################
#Number of additional top perforing equities to be used in Optimization
n = 100
#Starting Retail Portfolio in $
Rportfolio = {'MU': 3000.0, 'MSFT': 4000.0, 'FB': 10000.0, 'T': 5000.0}
Rportv=Rportfolio.values()
#Funds for buying new equities, $
spending=10000
#Total $ value of new portfolio
total=sum(Rportfolio.values())+spending

#protfolio after optimization
Oportfolio=Rportfolio

#######################Starting Retail Portfolio Data###########################

#List of current portfolio ticker symbols
symbols=Rportfolio.keys()

#Builds DataFrame of prices for current portfolio 
date=dt.datetime.today().strftime("%Y/%m/%d")
Rprices = pd.DataFrame()
for sym in symbols:
    Rprices[sym] = web.DataReader(sym, data_source='yahoo',end=date)['Adj Close']

#Reduces DataFrame to past 2 years of data
Rprices=Rprices[-504:]

#creates a new DataFrame from equity returns
Rrets = np.log(Rprices/Rprices.shift(1))


#orginal portfolio sharpe 
w = np.array(Rportfolio.values()/sum(Rportfolio.values()))
pret = np.sum(Rrets.mean() * w) * 252
pvol = np.sqrt(np.dot(w.T, np.dot(Rrets.cov() * 252, w)))
sharpe1=pret/pvol
print pret / pvol

#adds orginal portfolio share numbers to optimal portfolio 
for key, value in Oportfolio.items():
    Oportfolio[key]=value/Rprices[key].iloc[-1] 

################Data Retrieval and Reformatting#################################

#Retrieves Price Data Generated by Global Equity data Agregation and Cleaning.py
prices= pd.read_csv(r'C:\Users\XangryeyesX\Desktop\GlobalStocksPrices.csv')
prices=prices.set_index("Date")
prices=prices.replace(10000000,np.nan)
prices=prices.ffill()

#creates a new DataFrame from Equity Returns
rets = np.log(prices/prices.shift(1))

################Data Statics Creation and Data Transformation###################

#Creates Panda Series of Annualised Returns
Arets=rets.mean()*252

#Creates Panda Series of Annualised Volatility
Stdev = sqrt(rets.var()*252)

# Creates a Sharpe Ratio Value for Each Remaining Equity
sharpe = (Arets)/(Stdev)

#Converts sharpe pandas series into a DataFrame
sharpe=pd.DataFrame(sharpe,columns=['sharpe'])

#Converts Arets into a DataFrame
Arets= pd.DataFrame(Arets, columns=["Rbar"])

#Adds Sharpe Colomn to the Arets DataFrame
Arets["Sharpe"] = sharpe["sharpe"]

count=0
for sym in Arets.index.tolist():
    try:
        if Arets.isnull().loc[sym,"Sharpe"] == True:
            Arets=Arets.drop(sym,axis=0)
    except:
        print sym
    count+=1
    print count


# Lists equities by Sharpe ratio in descending order
Arets.sort_values("Sharpe",ascending=False,inplace=True)

#Cuts list of equities down to the ones with top 100 Sharpe ratios 
Arets=Arets.head(n)

#Reduces rets DataFrame to only those remaining in Arets
count=0
for sym in rets.columns:
    try:
        Arets.loc[sym]
    except:
            rets=rets.drop(sym,axis=1)
            count+=1
            print count

#Combines DataFrames of original portfolio equity returns and returns of Optimization equities
Nrets = pd.concat([Rrets.reset_index(),rets.reset_index()],axis=1)
Nrets=Nrets.set_index("Date")


#######################Portfolio Optimization###################################
## constraints for optimization
#1 Weights must sum to 1
#2 No short selling
#3 Orginal portfolio $ amounts don't change

#Random rate generation function
def rand_weights(m):
    ''' Produces n random weights that sum to 1 '''
    k = np.random.rand(m)
    l =((k/sum(k))*spending)/total
    return l

#Builds initial list of Equity Weights
Iweights=rand_weights(n)

# Key Statcis needed for calulation of sharpe function used in optimization
def statistics(weights):
    ''' Return expected return, variance, and Sharpe ratio of a portfolio '''
    tw = (Rportv/total).tolist()+weights.tolist()
    w = np.array(tw)
    pret = np.sum(Nrets.mean() * w) * 252
    pvol = np.sqrt(np.dot(w.T, np.dot(Nrets.cov() * 252, w)))
    return np.array([pret, pvol, pret / pvol]) 

# Function to be used by Optimization
def neg_sharpe(weights):
    return -statistics(weights)[2]

#Constraints used by Optimization
cons = ({'type':'eq', 
         'fun': lambda x: np.sum(x) - sum(Iweights)})


bnds = tuple((0, 1) for x in range(n))


    
opts = sco.minimize(neg_sharpe,Iweights, method='SLSQP',bounds=bnds, 
                        constraints=cons)

#Creates the new Optimizated portfolios with the $ amounts
for x in xrange(n):
   Oportfolio[rets.mean().index.tolist()[x]]=opts.x[x]*total/prices[sym].iloc[-1]


print opts.fun*-1.0
print Oportfolio
       

         